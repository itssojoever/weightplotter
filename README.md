This project is an attempt to build on knowledge of matplotlib whilst introducing new libraries, including CSV and pandas. Using a GUI, the user can select the date, desired weight, current weight, and unit of measurement. These values are then saved, after which a verify function checks that they conform with the necessary format (numbers for weights, for example). Although it may seem back to front to save and then verify, a function to remove the last entry ensures that if the entry is non-conform, it is deleted from the CSV file and the configuration file. This is, nevertheless, an ad-hoc solution to an oversight and the ideal situation would be to not save the non-conform data in the first place.

-------------------------

The calendar, using the tkcalendar library, allows the user to select the date of entry, while the unit of measurement can be picked below. Although the calendar allows users to retrospectively input data, the comma separated values are sorted before the visualization is shown, and consequently the dates are ordered correctly on the chart, no matter the order in which the information is inputted. Moreover, the datetime library is used to get the current date, month, and year, and then set the calendar to this day. This avoids hardcoding a date into the calendar, and, presuming the user is inputting data on the same day, speeds up data entry.

-------------------------

The verifyFields() function is long, and surely has redundancies and doesn't cover all eventualities; this being said, the most glaring problems are ironed out by this function, which is called after the save button is pressed. Included in this function is a check to ensure that the number for weight provided isn't too low: this avoids negative or unrealistic numbers being inputted. There are also checks to ensure that the data entered into the weight fields are numbers, as opposed to letters or other symbols, which would cause an exception with the plotting function. Finally, a check ensures that all fields are completed as the lack of an input would, as before, break the plotting function. On any relevant fail the removeLastEntry() function is called, removing the non-conform data from the two files which store entries: this is an ad-hoc solution, but functions well. Future work on this function would focus on accounting for more possible faults, but also on refactoring the code such that the information is checked before saving, as opposed to accounting for it afterwards.

-------------------------

The saving data function works by assigning the entries to the fields to variables and then inputting those entries into config.ini or inputdata.csv as strings. Perhaps the most important thing I learnt here was that I needed to add headers to the CSV file, which is why the columnsExist variable takes the value of whether or the file exists, even before the file is created. If the file does not exist then the headers do not either, and so they're later created. On subsequent runs of the program, because the CSV has been created and the headers written into it, the condition of line 33 is not satisfied and additional headers aren't subsequently created on lines 38 and 39. Surely not that innovative a solution but it works.

An interesting choice was to split the entries across two separate files: the .ini and the .csv. In hindsight this has created a lot more code than might be necessary, but at the time I justified it on the basis that the data for the .ini file was more permanent, while the .csv file would be frequently appended. I thought that storing the date and target weight, which is a much better term of phrase than desired weight, in the .csv would complicate the matplotlib plotting, but, having now coded the plotting function, this perception does not hold water. Future work on this code could merge the two into one, storing the more permanent data in the .csv file, rather than a .ini

-------------------------

The plotting function is called by the "view visualization" button, positioned alongside the save and load buttons. Upon being called, the entries in the .ini and .csv files are read, resampled, and assigned to variables as needed. These variables are passed to the relevant matplotlib methods. Design choices, insofar as they can be called design, include a transparent red fill between the current weight and target weight, upper and lower padding respectively above the target weight and below the minimum weight, and a y label that changes according to which measurement was picked. This section is still very much a work in progress but is functional. Future improvements will focus on the presentation of the information, as at present, while functional, it could look better: especially with respect to the dates and what to do when there is a large gap between date entries
